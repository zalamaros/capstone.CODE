<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Animated LA Map</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f0f0f0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.176.0/build/three.module.js';
        import { SVGLoader } from 'https://unpkg.com/three@0.176.0/examples/jsm/loaders/SVGLoader.js';
        let scene, camera, renderer;
        let animatedLines = [];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.OrthographicCamera(
                window.innerWidth / -200,
                window.innerWidth / 200,
                window.innerHeight / 200,
                window.innerHeight / -200,
                0.1,
                1000
            );
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const loader = new SVGLoader();
            loader.load('LA-svg.svg', (data) => {
                const paths = data.paths;

                paths.forEach((path) => {
                    const points = path.getPoints(200);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    geometry.setDrawRange(0, 0);

                    const material = new THREE.LineBasicMaterial({
                        color: 0x2e8b57,
                        linewidth: 1
                    });

                    const line = new THREE.Line(geometry, material);
                    line.scale.set(0.005, -0.005, 1);
                    line.position.set(-2.5, 2.5, 0);

                    scene.add(line);
                    animatedLines.push({ geometry, progress: 0 });
                });
            });

            window.addEventListener('resize', onWindowResize);
        }

        function animate() {
            requestAnimationFrame(animate);

            animatedLines.forEach((item) => {
                const totalPoints = item.geometry.attributes.position.count;
                if (item.progress < totalPoints) {
                    item.progress += 2;
                    item.geometry.setDrawRange(0, item.progress);
                } else {
                    const scaleFactor = 1 + 0.005 * Math.sin(Date.now() * 0.005);
                    item.geometry.attributes.position.needsUpdate = true;
                }
            });

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.left = window.innerWidth / -200;
            camera.right = window.innerWidth / 200;
            camera.top = window.innerHeight / 200;
            camera.bottom = window.innerHeight / -200;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>